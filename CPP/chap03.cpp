/* Chapter 03: CLASS */

/* HelloOOP1.c */
#include <stdio.h>

typedef struct USERDATA
{
    int nAge;
    char szName[32];
} USERDATA;

int main(void)
{
    USERDATA user = {20, "hey"};
    printf("%d, %s\n", user.nAge, user.szName);
}



//==========================================================
/* HelloOOP.cpp
  exercise class */
#include <cstdio>

class USERDATA
{
public:

    int nAge;
    char szName[32];

    void Print(void)
    {
        printf("%d, %s\n", nAge, szName);
    }
};

int main(int argc, char* argv[])
{
    USERDATA user = {10, "hey"};

    user.Print();

    return 0;
}



//==========================================================
/* MemberInit1.cpp */
#include <iostream>
using namespace std;

class CTest
{
public:

    // Creative Functions - initialization
    CTest()
    {
        m_nData = 10;
    }

    int m_nData;

    void PrintData(void)
    {
        cout << m_nData << endl;
    }
};

int main(int argc, char* argv[])
{
    CTest t;
    t.PrintData();

    return 0;
}



//==========================================================
/* MemberInit3.cpp */
#include <iostream>
using namespace std;

class CTest
{
public:

    // Creative Functions - initialization
    CTest()
    {
        m_nData = 10;
    }

    int m_nData;

    // seperate the declaration and definition
    void PrintData(void);
};

void CTest::PrintData(void)
{
    cout << m_nData << endl;
}

int main(int argc, char* argv[])
{
    CTest t;
    t.PrintData();

    return 0;
}



//==========================================================
/* MemberInit4.cpp */
#include <iostream>
using namespace std;

class CTest
{
public:

    // Creative Functions - initialization
    CTest()
        : m_nData1(10), m_nData2(20)
    {}

    // declare
    int m_nData1;
    int m_nData2;

    // seperate the declaration and definition
    void PrintData(void)
    {
        cout << m_nData1 << endl;
        cout << m_nData2 << endl;
    }
};

int main(int argc, char* argv[])
{
    CTest t;
    t.PrintData();

    return 0;
}



//==========================================================
/* MemberInit5.cpp 
 
   icc MemberInit5.cpp -std=c++11 */
#include <iostream>
using namespace std;

class CTest
{
public:

    // Creative Functions - initialization
    CTest() {}

    // declare and initialize (c++11 style)
    int m_nData1 = 10;
    int m_nData2 = 20;

    // seperate the declaration and definition
    void PrintData(void)
    {
        cout << m_nData1 << endl;
        cout << m_nData2 << endl;
    }
};

int main(int argc, char* argv[])
{
    CTest t;
    t.PrintData();

    return 0;
}


//==========================================================
/* AccessCtrl.cpp */
#include <iostream>
using namespace std;

class CMyData
{
    // this is 'private' 
    int m_nData;

public:
    int GetData(void) { return m_nData; }
    void SetData(int nParam) { m_nData = nParam; }
};

int main(int argc, char* argv[])
{
    CMyData data;
    data.SetData(10);
    cout << data.GetData() << endl;

    return 0;
}


/* Constructor1.cpp 
   Every classes have both constructor and destructor
*/
#include <iostream>

using namespace std;

class CTest
{
public:
    CTest()
    {
        cout << "CTest::CTest()" << endl;
    }

    ~CTest()
    {
        cout << "~CTest::CTest()" << endl;
    }
};

int main(int argc, char* argv[])
{
    cout << "Begin" << endl;
    CTest a;
    cout << "End" << endl;

    return 0;
}



//==========================================================
/* Constructor2.cpp
*/
#include <iostream>
using namespace std;

class CTest
{
    // private variable 
    int m_nData;

public:
    // initialize without default value
    CTest(int nParam): m_nData(nParam)
    {
        cout << "CTest::CTest()" << endl;
    }

    ~CTest()
    {
        cout << "~CTest::CTest()" << m_nData << endl;
    }
};

int main(int argc, char* argv[])
{
    cout << "Begin" << endl;
    CTest a(1);
    cout << "Before b" << endl;
    CTest b(2);
    cout << "End" << endl;

    return 0;
}



//==========================================================
/* ClassNew.cpp 
*/
#include <iostream>
using namespace std;

class CTest
{
    int m_nData;

public:
    CTest()
    {
        cout << "CTest::CTest()" << endl;
    }

    ~CTest()
    {
        cout << "~CTest::CTest()" << endl;
    }
};

int main(int argc, char* argv[])
{
    cout << "Begin" << endl;

    // generate dynamic object with "new" operator
    // CTest *pData = new CTest;
    // if it is generated by array, then it also should be deleted by array (see below)
    CTest *pData = new CTest[3];
    cout << "Test" << endl;

    // must be deleted by "delete"
    // delete pData;
    delete [] pData;
    cout << "End" << endl;

    return 0;
}



//==========================================================
/* RefSample.cpp
*/
#include <iostream>
using namespace std;

class CRefTest
{
    public:
        // reference variables should be initialized in this initialization 
        CRefTest(int &rParam): m_nData(rParam) {};
        int GetData(void) { return m_nData; }

    private:
        int &m_nData;
};

int main(int argc, char* argv[])
{
    int a = 10;
    CRefTest t(a);

    cout << t.GetData() << endl;

    a = 20;
    cout << t.GetData() << endl;

    return 0;
}



//==========================================================
/* ConstructorOver1.cpp
*/
#include <iostream>
using namespace std;

class CMyData
{
public:
    // Multiple constructor can be generated
    CMyData(int nParam): m_nData(nParam) {};

    CMyData(int x, int y): m_nData(x+y) {};

    int GetData(void) { return m_nData; }

private:
    int m_nData;
};

int main(int argc, char* argv[])
{
    CMyData a(10);
    CMyData b(3,4);

    cout << a.GetData() << endl;
    cout << b.GetData() << endl;

    return 0;
}
 


//==========================================================
/* ConstructorOver2.cpp
*/
#include <iostream>
using namespace std;

class CMyPoint
{
public:
    CMyPoint(int x)
    { 
        cout << "CMyPoint(int)" << endl;

        if (x>100)
            x = 100;

        m_x = x;
    }

    CMyPoint(int x, int y)
    // The upper constructor can be re-used
        : CMyPoint(x)
    {
        cout << "CMyPoint(int,int)" << endl;

        if (y>200)
            y=200;

        m_y = y;
    }

    void Print()
    {
        cout << "X: " << m_x << endl;
        cout << "Y: " << m_y << endl;
    }

private:
    int m_x=0;
    int m_y=0;
};

int main(int argc, char* argv[])
{
    CMyPoint ptBegin(110);
    ptBegin.Print();

    CMyPoint ptEnd(50,250);
    ptEnd.Print();

    return 0;
}


//==========================================================
/* ExpDefaultConstructor.cpp 
*/
#include <iostream>
using namespace std;

class CTest
{
public:
    CTest(void) = default;
    //CTest(void);
    int m_nData = 5;
};

// creat the default constructor out of the class
//CTest::CTest(void) {}

int main(int argc, char* argv[])
{
    CTest a;
    cout << a.m_nData << endl;

    return 0;
}



//==========================================================
/*ThisPointer.cpp
*/
#include <iostream>
using namespace std;

class CMyData
{
public:
    CMyData(int nParam): m_nData(nParam) {};
    void PrintData()
    {
        // 1. basic print-out
        cout << m_nData << endl;
        // 2. print-out with class member
        cout << CMyData::m_nData << endl;
        // 3. call the method of "this" pointer
        cout << this->m_nData << endl;
        // 4. Best way for the print-out
        cout << this->CMyData::m_nData << endl;
    }

private:
    int m_nData;
};

int main(int argc, char* argv[])
{
    CMyData a(5), b(10);
    a.PrintData();
    b.PrintData();

    return 0;
}



//==========================================================
/* ConstMethod1.cpp
*/
#include <iostream>
using namespace std;

class CTest
{
public:
    // Constructor
    CTest(int nParam): m_nData(nParam) {};
    // Destructor
    ~CTest() {}

    // declaration and definition of the constant method
    int GetData() const
    {
        // Only read the values of the member instance, 
        // but cannot write on it
        return m_nData;
    }
private:
    int m_nData = 0;
};

int main(int argc, char* argv[])
{
    CTest a(10);
    cout << a.GetData() << endl;

    return 0;
}



//==========================================================
/* ConstMethod2.cpp
 *
 *  Mutable (normal instance) and const_cast<> (reference instance) in using Constant Method
*/
#include <iostream>
using namespace std;

class CTest
{
public:
    // Constructor
    CTest(int nParam): m_nData(nParam) {};
    // Destructor
    ~CTest() {}

    // declaration and definition of the constant method
    int GetData() const
    {
        // The member instance can be written if it is mutable !!
        m_nData = 20;
        return m_nData;
    }
private:
    mutable int m_nData = 0;
};

int main(int argc, char* argv[])
{
    CTest a(10);
    cout << a.GetData() << endl;

    return 0;
}



//==========================================================
/* ConstCastSample.cpp
 * const_cast<>: it makes the "const" method reference instances writable
*/
#include <iostream>
using namespace std;

// reference instance
void TestFunc(const int &nParam)
{
    // type would be changed from the "const" to "int" reference
    int &nNewParam = const_cast<int &>(nParam);
    nNewParam = 20;
}

int main(int argc, char* argv[])
{
    int nData = 10;

    TestFunc(nData);

    cout << nData << endl;

    return 0;
}


//==========================================================
/* MemberOver1.cpp
 */
#include <iostream>
using namespace std;

class CMyData
{
public:
    CMyData(): m_nData(0) {};
    
    int GetData(void) { return m_nData; }
    // multiple definitions of the method
    void SetData(int nParam) { m_nData = nParam; }
    void SetData(double dParam) { m_nData = 0; }

private:
    int m_nData;
};

int main(int argc, char* argv[])
{
    CMyData a;
    a.SetData(10);
    cout << a.GetData() << endl;

    CMyData b;
    b.SetData(5.5);
    cout << b.GetData() << endl;
        
    return 0;
};



//==========================================================
/* MemberOver2.cpp
 */
#include <iostream>
using namespace std;

class CMyData
{
public:
    CMyData(): m_nData(0) {};

    int GetData(void) { return m_nData; }
    void SetData(int nParam) { m_nData = nParam; }

    // prevent the unintended format from being inserted 
    void SetData(double dParam) = delete;

private:
    int m_nData;
};

int main(int argc, char* argv[])
{
    CMyData a;
    a.SetData(10);
    cout << a.GetData() << endl;

    CMyData b;
    b.SetData(5.5);
    cout << b.GetData() << endl;

    return 0;
}


//==========================================================
/* StaticMember.cpp
 */
#include <iostream>
using namespace std;

class CTest
{
public:
    CTest(int nParam): m_nData(nParam) { m_nCount++; }
    int GetData() { return m_nData; };
    void ResetCount() { m_nCount = 0; };

    // declaration and definition of static method
    static int GetCount()
    {
        return m_nCount;
    };
private:
    int m_nData;
    // declaration of static member instance
    static int m_nCount;
};

// definition of the static member 
int CTest::m_nCount = 0;

int main(int argc, char* argv[])
{
    CTest a(5), b(10);
    cout << a.GetCount() << endl;

    b.ResetCount();
    cout << CTest::GetCount() << endl;

    return 0;
}
